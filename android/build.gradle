// // The Android Gradle Plugin builds the native code with the Android NDK.

// group = "ph.integritynet.boringssl_ffi"
// version = "1.0"

// buildscript {
//     repositories {
//         google()
//         mavenCentral()
//     }

//     dependencies {
//         // The Android Gradle Plugin knows how to build native code with the NDK.
//         classpath("com.android.tools.build:gradle:8.7.3")
//     }
// }

// rootProject.allprojects {
//     repositories {
//         google()
//         mavenCentral()
//     }
// }

// apply plugin: "com.android.library"

// android {
//     namespace = "ph.integritynet.boringssl_ffi"

//     // Bumping the plugin compileSdk version requires all clients of this plugin
//     // to bump the version in their app.
//     compileSdk = 35

//     // Use the NDK version
//     // declared in /android/app/build.gradle file of the Flutter project.
//     // Replace it with a version number if this plugin requires a specific NDK version.
//     // (e.g. ndkVersion "23.1.7779620")
//     ndkVersion = android.ndkVersion

//     // Invoke the shared CMake build with the Android Gradle Plugin.
//     externalNativeBuild {
//         cmake {
//             path = "../src/CMakeLists.txt"

//             // The default CMake version for the Android Gradle Plugin is 3.10.2.
//             // https://developer.android.com/studio/projects/install-ndk#vanilla_cmake
//             //
//             // The Flutter tooling requires that developers have CMake 3.10 or later
//             // installed. You should not increase this version, as doing so will cause
//             // the plugin to fail to compile for some customers of the plugin.
//             // version "3.10.2"
//         }
//     }

//     compileOptions {
//         sourceCompatibility = JavaVersion.VERSION_11
//         targetCompatibility = JavaVersion.VERSION_11
//     }

//     defaultConfig {
//         minSdk = 21
//     }
// }


// The Android Gradle Plugin builds the native code with the Android NDK.

group = "ph.integritynet.boringssl_ffi"
version = "1.0"

// This `buildscript` block is unchanged.
buildscript {
    repositories {
        google()
        mavenCentral()
    }

    dependencies {
        classpath("com.android.tools.build:gradle:8.7.3")
    }
}

rootProject.allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

apply plugin: "com.android.library"

android {
    namespace = "ph.integritynet.boringssl_ffi"
    compileSdk = 35

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    defaultConfig {
        minSdk = 21
    }

    // ===================================================================
    // =========== INTELLIGENT NATIVE BUILD CONFIGURATION ================
    // ===================================================================

    // 1. Define the location of our pre-compiled libraries.
    def prebuiltSoDir = new File(project.projectDir, 'src/main/jniLib')

    // 2. Define the ABIs your plugin supports.
    //    (arm64-v8a for new devices, armeabi-v7a for older 32-bit, x86_64 for emulators)
    def supportedAbis = ['arm64-v8a', 'armeabi-v7a', 'x86_64']

    // 3. Check if the pre-compiled .so files exist for all supported ABIs.
    def prebuiltLibrariesExist = supportedAbis.every { abi ->
				println("boringssl_ffi: prebuiltLibrariesExist looking for ${prebuiltSoDir}/${abi}/libboringssl_ffi.so")
        new File(prebuiltSoDir, "${abi}/libboringssl_ffi.so").exists()
    }

    // 4. Main Logic: Decide whether to build from source or use pre-builts.
    if (prebuiltLibrariesExist) {
        // --- CONSUMER PATH ---
        // Pre-compiled .so files were found. Skip the NDK/CMake build entirely.
        println("boringssl_ffi: Found pre-compiled libraries in src/main/jniLibs. Skipping native build.")
        
        // Point Gradle to the directory containing the .so files so they are
        // packaged into the final app.
        sourceSets {
            main {
                jniLibs.srcDirs = [prebuiltSoDir]
            }
        }

    } else {
        // --- MAINTAINER PATH ---
        // Pre-compiled .so files were NOT found. Configure and run the native CMake build.
        println("boringssl_ffi: Pre-compiled libraries not found. Starting native build.")

        // Use the NDK version from the main Flutter project.
        ndkVersion = android.ndkVersion

				println("android.ndkVersion ${android.ndkVersion}")
				println("android.ndkDirectory ${android.ndkDirectory}")
				

        // Configure the native build.
        externalNativeBuild {
            cmake {
                // Path to your root CMakeLists.txt file.
                path = "../src/CMakeLists.txt"
                // No version needed, we'll use the AGP default.
            }
        }

        // Specify which architectures to build.
        defaultConfig {
            ndk {
                abiFilters.addAll(supportedAbis)
            }
        }

				afterEvaluate {
            android.libraryVariants.all { variant ->
                if (!prebuiltLibrariesExist) { // Only add dependency if libraries don't exist
                    def preBuildTask = variant.preBuildProvider.get()
                    preBuildTask.dependsOn(tasks.named('buildNativeAndroidLibraries'))
                    println("boringssl_ffi: Auto-hooked 'buildNativeAndroidLibraries' to '${preBuildTask.name}'")
                }
            }
        }
    }
    // ===================================================================
    // ======================= END OF NATIVE BUILD =======================
    // ===================================================================
}

// Task to perform the native build for all supported ABIs and copy to jniLibs
tasks.register('buildNativeAndroidLibraries') {
    group = "boringssl_ffi"
    description = "Builds the native BoringSSL FFI library for Android ABIs and copies to jniLibs."
		def prebuiltSoDir = new File(project.projectDir, 'src/main/jniLib')
		def supportedAbis = ['arm64-v8a', 'armeabi-v7a', 'x86_64']
		def rootBuildPath = project.buildDir.toPath()

    doLast {
        // Ensure the jniLibs directory exists
        mkdir(prebuiltSoDir)
        
        // Get the path to CMakeLists.txt
        def cmakeSourceDir = project.file("../src")

				def currentBuildType = ""
        project.gradle.taskGraph.allTasks.each { task ->
            if (task.name.toLowerCase().contains("debug")) {
                currentBuildType = "debug"
            } else if (task.name.toLowerCase().contains("release")) {
                currentBuildType = "release"
            }
            // Break loop once determined
            if (currentBuildType != "") return
        }
        if (currentBuildType == "") {
            println("Warning: Could not determine current build type. Defaulting to 'debug'.")
            currentBuildType = "debug"
        }
        println("Determined current build type for copying: ${currentBuildType}")

        supportedAbis.each { abi ->
            println("Copying compiled native library for ABI: ${abi} from AGP's stripped build output.")

            // Construct the source path for the stripped native library
            // This path is relative to your plugin's build directory: boringssl_ffi/android/build
            def sourceSoFile = new File(project.buildDir,
                "intermediates/stripped_native_libs/${currentBuildType}/stripDebugDebugSymbols/out/lib/${abi}/libboringssl_ffi.so")

            if (!sourceSoFile.exists()) {
                // Fallback for release builds if 'stripDebugDebugSymbols' name is variant-specific
                // or if it's 'stripReleaseDebugSymbols'
                sourceSoFile = new File(project.buildDir,
                    "intermediates/stripped_native_libs/${currentBuildType}/stripReleaseDebugSymbols/out/lib/${abi}/libboringssl_ffi.so")
            }

            if (!sourceSoFile.exists()) {
                throw new Exception("CRITICAL ERROR: AGP's stripped native library output for ${abi} and build type '${currentBuildType}' not found at expected path: ${sourceSoFile.absolutePath}. Please ensure AGP's strip task ran successfully.")
            } else {
                println("DEBUG: Source stripped file found: ${sourceSoFile.absolutePath}")
            }

            def targetJniLibDir = new File(prebuiltSoDir, abi)
            mkdir(targetJniLibDir)

            // Copy the compiled .so file from AGP's stripped output to the jniLibs directory
            copy {
                from sourceSoFile
                into targetJniLibDir
                rename { String fileName -> "libboringssl_ffi.so" }
            }

            println("Copied ${sourceSoFile.name} to ${targetJniLibDir.absolutePath}")

            // Sanity check after copy
            def finalSoFile = new File(targetJniLibDir, "libboringssl_ffi.so")
            if (!finalSoFile.exists()) {
                throw new Exception("CRITICAL ERROR: File ${finalSoFile.absolutePath} was NOT found in destination AFTER copy from AGP stripped output.")
            }
        }

        // Create the marker file after all ABIs are successfully built
        // prebuiltMarkerFile.createNewFile()
        // println("Created marker file: ${prebuiltMarkerFile.absolutePath}")
        println("Native Android libraries built and copied successfully to ${prebuiltSoDir.absolutePath}")
    }
}

// Task to clean the generated native libraries and the marker file
tasks.register('cleanNativeAndroidLibraries') {
    group = "boringssl_ffi"
    description = "Cleans pre-compiled Android native libraries and the marker file."

    doLast {
        delete prebuiltSoDir
        delete prebuiltMarkerFile
        println("Cleaned pre-compiled Android libraries from ${prebuiltSoDir.absolutePath} and marker file.")
    }
}